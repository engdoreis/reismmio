// Copyright (c) 2025 Douglas Reis.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

use askama::Template;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

use crate::filters;
use crate::mmio;
use crate::schema;

use regex::Regex;

static FILE_HEADER: &str = r#"
/*
 * This file is autogenerated by the tool reismmio.
 */
"#;

fn device_type(s: &str) -> String {
    let re = Regex::new(r"\d+$").unwrap();
    // Remove trailing digits
    re.replace(s, "").to_string().to_lowercase()
}

pub mod cpp {
    use super::*;

    #[derive(Template)]
    #[template(
        ext = "txt",
        source = "
#include  <cstdint>
namespace platform  {
{% for device_type in data.device_types -%}
    /* Addresses for the devices of the type {{ device_type.type_name|pascal_case }}.*/
    enum {{ device_type.type_name|pascal_case }}: uintptr_t{ 
        {%- for device in device_type.devices -%}
            {{ device.name|pascal_case }} = {{device.address}},
        {%- endfor -%}
    };

{% endfor -%}
} // namespace platform
"
    )]
    pub struct Platform<'a> {
        pub data: &'a mmio::Platform,
    }

    #[derive(Template)]
    #[template(
        ext = "txt",
        source = "
/* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
struct {{ data.name|pascal_case }} { 
    {% for register in data.registers -%}
    {{ register|pascal_case }}Reg {{register|lower}};
    {% endfor %}
    
    constexpr {{ data.name|pascal_case }} (platform::{{ data.name|pascal_case }} addr): 
    {%- for register in data.registers -%}
        {{register|lower}}(addr) {%- if !loop.last -%},{%- endif -%}
    {%- endfor -%}
    {}
};

"
    )]
    pub struct Device<'a> {
        pub data: &'a mmio::Device<'a>,
    }

    #[derive(Template)]
    #[template(
        ext = "txt",
        source = "
/* {{ data.desc }} */
union {{ data.name|pascal_case }}Reg { 
    reismmio::Register reg;
    {% for bitfield in data.bitfields -%}
    /* {{ bitfield.desc }} */
    reismmio::BitField<{{ bitfield.offset }}, {{ bitfield.bit_size }}, reismmio::Permissions::{{ bitfield.permissions }}> {{ bitfield.name|lower }};
    {% endfor -%}
    
    constexpr {{ data.name|pascal_case }}Reg (uintptr_t addr): reg{.addr = addr + {{ data.offset }}}
    {}

    inline void commit() { reg.commit(); }

    inline {{ data.name|pascal_case }}Reg& fetch() {
        reg.fetch();
        return *this;
    }
};

"
    )]
    pub struct Register<'a> {
        pub data: &'a mmio::Register<'a>,
    }

    pub fn generate(
        soc: &schema::Device,
        out_dir: PathBuf,
        addr_dir: PathBuf,
    ) -> anyhow::Result<()> {
        let get_path = |path: &PathBuf, name: &str| -> anyhow::Result<(PathBuf, File)> {
            let mut filename = path.clone();
            filename.push(name);
            filename.set_extension("hh");
            let mut file = File::create(&filename)?;
            writeln!(file, "{}", FILE_HEADER)?;
            writeln!(file, "#pragma once")?;
            Ok((filename, file))
        };
        let _name = soc.name.replace(" ", "_").to_lowercase();
        // Store all the device addresses which will be rendered later in a single header under
        // a enum.
        let mut platform = mmio::Platform::new();
        for device_iter in &soc.peripherals.peripheral {
            // i.e 0x8000_0000
            let device_addr = device_iter.base_address;
            // i.e UART0
            let device_name = device_iter.name.replace(" ", "_").to_uppercase();
            // i.e UART
            let device_type =
                device_type(&device_iter.derived_from.as_ref().unwrap_or(&device_name));

            platform.add(device_type.clone(), device_name.clone(), device_addr);

            let Some(registers) = &device_iter.registers.as_ref() else {
                continue;
            };

            let (device_header, mut device_handler) = get_path(&out_dir, &device_type)?;

            write_device_header_top(&mut device_handler)?;

            writeln!(
                device_handler,
                "namespace {} {{",
                device_type.clone().to_lowercase()
            )?;

            let mut device = mmio::Device::new(&device_type);
            for register_iter in &registers.register {
                device.registers.push(&register_iter.name);

                let mut register = mmio::Register::new(
                    &register_iter.name,
                    register_iter.address_offset as u32,
                    Some(&register_iter.description),
                );
                for register_field in &register_iter.fields.field {
                    register.bitfields.push(mmio::Bitfields::new(
                        &register_field.name,
                        register_field.bit_range.offset as u32,
                        register_field.bit_range.size as u32,
                        register_field.access.clone(),
                        Some(&register_field.description),
                    ));
                }
                writeln!(
                    device_handler,
                    "{}",
                    Register { data: &register }.render().unwrap()
                )?;
            }
            writeln!(
                device_handler,
                "{}",
                Device { data: &device }.render().unwrap()
            )?;
            writeln!(
                device_handler,
                "}} // namespace {}\n}} // namespace mmio",
                device_type.to_lowercase()
            )?;
            println!("{} generated", device_header.display());
        }

        let (platform_fname, mut platform_fd) = get_path(
            &addr_dir,
            &format!("{}_platform", soc.name.replace(" ", "_").to_lowercase()),
        )?;
        writeln!(
            platform_fd,
            "{}",
            Platform { data: &platform }.render().unwrap()
        )?;
        println!("{} generated", platform_fname.display());

        std::fs::write(
            out_dir.join("mmio.hh"),
            include_str!("../../resources/mmio.hh"),
        )?;
        Ok(())
    }

    fn write_device_header_top(fd: &mut std::fs::File) -> anyhow::Result<()> {
        writeln!(
            fd,
            "/* The `platform.hh` should be created and include the specific platform header which will contain the device addresses.*/"
        )?;
        writeln!(fd, r###"#include  "platform.hh" "###)?;
        writeln!(fd, r###"#include  "mmio.hh" "###)?;
        writeln!(fd, "namespace mmio {{")?;
        Ok(())
    }
}
