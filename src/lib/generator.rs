// Copyright (c) 2025 Douglas Reis.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

use askama::Template;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

use crate::filters;
use crate::mmio;
use crate::schema;

use regex::Regex;

static FILE_HEADER: &str = r#"
/*
 * This file is autogenerated by the tool reismmio.
 */
"#;

fn device_name(s: &str) -> String {
    let re = Regex::new(r"\d+$").unwrap();
    // Remove trailing digits
    re.replace(s, "").to_string().to_lowercase()
}

pub mod cpp {
    use super::*;

    #[derive(Template)]
    #[template(
        ext = "txt",
        source = "
    #include <cstdint>
    namespace platform {
        enum Devices: uintptr_t{ 
            {% for device in data.devices -%}
            {{ device.name|pascal_case }} = {{device.address}},
            {% endfor -%}
        };
    };
    "
    )]
    pub struct DeviceAddresses<'a> {
        pub data: &'a mmio::DeviceAddresses<'a>,
    }

    #[derive(Template)]
    #[template(
        ext = "txt",
        source = "
     /* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
     struct {{ data.name|pascal_case }} { 
        {% for register in data.registers -%}
        {{ register|pascal_case }}Reg {{register|lower}};
        {% endfor %}
        
        constexpr {{ data.name|pascal_case }} (uintptr_t addr): 
        {%- for register in data.registers -%}
            {{register|lower}}(addr) {%- if !loop.last -%},{%- endif -%}
        {%- endfor -%}
        {}
     };

    "
    )]
    pub struct Device<'a> {
        pub data: &'a mmio::Device<'a>,
    }

    #[derive(Template)]
    #[template(
        ext = "txt",
        source = "
     /* {{ data.desc }} */
     union {{ data.name|pascal_case }}Reg { 
        reismmio::Register reg;
        {% for bitfield in data.bitfields -%}
        /* {{ bitfield.desc }} */
        reismmio::BitField<{{ bitfield.offset }}, {{ bitfield.bit_size }}> {{ bitfield.name|lower }};
        {% endfor -%}
        
        constexpr {{ data.name|pascal_case }}Reg (uintptr_t addr): reg{.addr = addr + {{ data.offset }}}
        {}

        inline void commit() { reg.commit(); }

        inline {{ data.name|pascal_case }}Reg& fetch() {
            reg.fetch();
            return *this;
        }
     };

    "
    )]
    pub struct Register<'a> {
        pub data: &'a mmio::Register<'a>,
    }

    pub fn generate(
        soc: &schema::Device,
        out_dir: PathBuf,
        addr_dir: PathBuf,
    ) -> anyhow::Result<()> {
        let get_path = |path: &PathBuf, name: &str| -> anyhow::Result<(PathBuf, File)> {
            let mut filename = path.clone();
            filename.push(name);
            filename.set_extension("hh");
            let mut file = File::create(&filename)?;
            writeln!(file, "{}", FILE_HEADER)?;
            writeln!(file, "#pragma once")?;
            Ok((filename, file))
        };
        let name = soc.name.replace(" ", "_").to_lowercase();
        // Store all the device addresses which will be rendered later in a single header under
        // a enum.
        let mut device_addr = mmio::DeviceAddresses {
            name: &name,
            devices: Vec::new(),
        };

        for device_iter in &soc.peripherals.peripheral {
            let name = device_iter.name.replace(" ", "_").to_uppercase();
            device_addr.devices.push(mmio::DeviceAddress {
                name,
                address: format!("{:#x}", device_iter.base_address),
            });

            let Some(registers) = &device_iter.registers.as_ref() else {
                continue;
            };

            let device_name = device_name(&device_iter.name);

            let (device_header, mut device_handler) = get_path(&out_dir, &device_name)?;

            writeln!(device_handler, r###"#include  "mmio.hh" "###)?;
            writeln!(
                device_handler,
                "namespace mmio {{\nnamespace {} {{",
                device_name.clone().to_lowercase()
            )?;

            let mut device = mmio::Device::new(&device_name);
            for register_iter in &registers.register {
                device.registers.push(&register_iter.name);

                let mut register = mmio::Register::new(
                    &register_iter.name,
                    register_iter.address_offset as u32,
                    Some(&register_iter.description),
                );
                for register_field in &register_iter.fields.field {
                    register.bitfields.push(mmio::Bitfields::new(
                        &register_field.name,
                        register_field.bit_range.offset as u32,
                        register_field.bit_range.size as u32,
                        Some(&register_field.description),
                    ));
                }
                writeln!(
                    device_handler,
                    "{}",
                    Register { data: &register }.render().unwrap()
                )?;
            }
            writeln!(
                device_handler,
                "{}",
                Device { data: &device }.render().unwrap()
            )?;
            writeln!(
                device_handler,
                "}} // namespace {}\n}} // namespace mmio",
                device_name.to_lowercase()
            )?;
            println!("{} generated", device_header.display());
        }

        let (platform_header, mut platform_header_handle) = get_path(
            &addr_dir,
            &format!("{}_devices", soc.name.replace(" ", "_").to_lowercase()),
        )?;
        writeln!(
            platform_header_handle,
            "{}",
            DeviceAddresses { data: &device_addr }.render().unwrap()
        )?;
        println!("{} generated", platform_header.display());
        std::fs::write(
            out_dir.join("mmio.hh"),
            include_str!("../../resources/mmio.hh"),
        )?;
        Ok(())
    }
}
